"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2480],{852(e,t,r){r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>o,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"calibra/breath","title":"CalibraBreath","description":"Breath capacity and control analysis for vocal performance assessment. Measures how well a singer manages their breathing by analyzing pitch contour data.","source":"@site/docs/calibra/breath.md","sourceDirName":"calibra","slug":"/calibra/breath","permalink":"/calibra/breath","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"docsSidebar","previous":{"title":"CalibraMusic","permalink":"/calibra/music"},"next":{"title":"CalibraSpeakingPitch","permalink":"/calibra/speaking-pitch"}}');var n=r(4848),i=r(8453);const c={sidebar_position:9},a="CalibraBreath",d={},l=[{value:"Quick Start",id:"quick-start",level:2},{value:"Kotlin",id:"kotlin",level:3},{value:"Swift",id:"swift",level:3},{value:"When to Use",id:"when-to-use",level:2},{value:"Methods",id:"methods",level:2},{value:"hasEnoughData",id:"hasenoughdata",level:3},{value:"Kotlin",id:"kotlin-1",level:4},{value:"Swift",id:"swift-1",level:4},{value:"Parameters",id:"parameters",level:4},{value:"computeCapacity",id:"computecapacity",level:3},{value:"Kotlin",id:"kotlin-2",level:4},{value:"Swift",id:"swift-2",level:4},{value:"Parameters",id:"parameters-1",level:4},{value:"getCumulativeVoicedTime",id:"getcumulativevoicedtime",level:3},{value:"Kotlin",id:"kotlin-3",level:4},{value:"Swift",id:"swift-3",level:4},{value:"Parameters",id:"parameters-2",level:4},{value:"computeMetrics",id:"computemetrics",level:3},{value:"Kotlin",id:"kotlin-4",level:4},{value:"Swift",id:"swift-4",level:4},{value:"Parameters",id:"parameters-3",level:4},{value:"Result Types",id:"result-types",level:2},{value:"BreathMetrics",id:"breathmetrics",level:3},{value:"Understanding Breath Capacity",id:"understanding-breath-capacity",level:2},{value:"Understanding Breath Control",id:"understanding-breath-control",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Post-Lesson Breath Report",id:"post-lesson-breath-report",level:3},{value:"Compare Student to Reference",id:"compare-student-to-reference",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Next Steps",id:"next-steps",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"calibrabreath",children:"CalibraBreath"})}),"\n",(0,n.jsx)(t.p,{children:"Breath capacity and control analysis for vocal performance assessment. Measures how well a singer manages their breathing by analyzing pitch contour data."}),"\n",(0,n.jsx)(t.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,n.jsx)(t.h3,{id:"kotlin",children:"Kotlin"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'// Extract pitch contour first\r\nval contour = pitchExtractor.extract(audio, sampleRate = 16000)\r\nval times = contour.toTimesArray()\r\nval pitches = contour.toPitchesArray()\r\n\r\n// Check if enough data (needs 5+ seconds of voiced audio)\r\nif (CalibraBreath.hasEnoughData(times, pitches)) {\r\n    val capacity = CalibraBreath.computeCapacity(times, pitches)\r\n    println("Breath capacity: $capacity seconds")\r\n}\r\n\r\n// Get total voiced time\r\nval voicedTime = CalibraBreath.getCumulativeVoicedTime(times, pitches)\r\nprintln("Total sung time: $voicedTime seconds")\n'})}),"\n",(0,n.jsx)(t.h3,{id:"swift",children:"Swift"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-swift",children:'// Extract pitch contour first\r\nlet contour = pitchExtractor.extract(audio: audio, sampleRate: 16000)\r\nlet times = contour.toTimesArray()\r\nlet pitches = contour.toPitchesArray()\r\n\r\n// Check if enough data (needs 5+ seconds of voiced audio)\r\nif CalibraBreath.hasEnoughData(times: times, pitchesHz: pitches) {\r\n    let capacity = CalibraBreath.computeCapacity(times: times, pitchesHz: pitches)\r\n    print("Breath capacity: \\(capacity) seconds")\r\n}\r\n\r\n// Get total voiced time\r\nlet voicedTime = CalibraBreath.getCumulativeVoicedTime(times: times, pitchesHz: pitches)\r\nprint("Total sung time: \\(voicedTime) seconds")\n'})}),"\n",(0,n.jsx)(t.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Scenario"}),(0,n.jsx)(t.th,{children:"Use This?"}),(0,n.jsx)(t.th,{children:"Why"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Analyze sustained note ability"}),(0,n.jsx)(t.td,{children:"Yes"}),(0,n.jsx)(t.td,{children:"Core use case"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Track breath improvement"}),(0,n.jsx)(t.td,{children:"Yes"}),(0,n.jsx)(t.td,{children:"Compare over time"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Compare student vs. reference"}),(0,n.jsx)(t.td,{children:"Yes"}),(0,n.jsxs)(t.td,{children:["Use ",(0,n.jsx)(t.code,{children:"computeMetrics"})]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Real-time breath feedback"}),(0,n.jsx)(t.td,{children:"No"}),(0,n.jsx)(t.td,{children:"Use pitch contour length instead"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Detect breathing moments"}),(0,n.jsx)(t.td,{children:"Partially"}),(0,n.jsx)(t.td,{children:"Use unvoiced gaps in pitch data"})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,n.jsxs)(t.p,{children:["All methods are static on the ",(0,n.jsx)(t.code,{children:"CalibraBreath"})," object (Kotlin) / class (Swift)."]}),"\n",(0,n.jsx)(t.h3,{id:"hasenoughdata",children:"hasEnoughData"}),"\n",(0,n.jsx)(t.p,{children:"Check if there is enough data for breath analysis. Requires at least 5 seconds of cumulative voiced audio to produce meaningful results."}),"\n",(0,n.jsx)(t.h4,{id:"kotlin-1",children:"Kotlin"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"val enough: Boolean = CalibraBreath.hasEnoughData(times, pitchesHz)\n"})}),"\n",(0,n.jsx)(t.h4,{id:"swift-1",children:"Swift"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-swift",children:"let enough: Bool = CalibraBreath.hasEnoughData(times: times, pitchesHz: pitches)\n"})}),"\n",(0,n.jsx)(t.h4,{id:"parameters",children:"Parameters"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Parameter"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"times"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Timestamps in seconds"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"pitchesHz"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Pitch values in Hz (-1 for unvoiced frames)"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Returns:"})," ",(0,n.jsx)(t.code,{children:"Boolean"})," / ",(0,n.jsx)(t.code,{children:"Bool"})," -- ",(0,n.jsx)(t.code,{children:"true"})," if there are at least 5 seconds of voiced audio."]}),"\n",(0,n.jsx)(t.h3,{id:"computecapacity",children:"computeCapacity"}),"\n",(0,n.jsx)(t.p,{children:"Compute breath capacity from a pitch contour. Measures the maximum duration of sustained voiced segments, indicating how long the singer can hold notes without breathing."}),"\n",(0,n.jsxs)(t.p,{children:["Internally resamples the pitch contour to a 10 Hz feature rate using ",(0,n.jsx)(t.code,{children:"SonixResampler"})," (libsamplerate), eliminates short non-breath silences, and models breath reserve as an exponential function."]}),"\n",(0,n.jsx)(t.h4,{id:"kotlin-2",children:"Kotlin"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"val capacity: Float = CalibraBreath.computeCapacity(times, pitchesHz)\n"})}),"\n",(0,n.jsx)(t.h4,{id:"swift-2",children:"Swift"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-swift",children:"let capacity: Float = CalibraBreath.computeCapacity(times: times, pitchesHz: pitches)\n"})}),"\n",(0,n.jsx)(t.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Parameter"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"times"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Timestamps in seconds"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"pitchesHz"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Pitch values in Hz (-1 for unvoiced frames)"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Returns:"})," ",(0,n.jsx)(t.code,{children:"Float"})," -- Breath capacity in seconds (longest sustained phrase). Returns ",(0,n.jsx)(t.code,{children:"-1"})," on failure. Returns at least ",(0,n.jsx)(t.code,{children:"1"})," on success."]}),"\n",(0,n.jsx)(t.h3,{id:"getcumulativevoicedtime",children:"getCumulativeVoicedTime"}),"\n",(0,n.jsx)(t.p,{children:"Calculate the total amount of time where pitch was detected (i.e., the singer was producing voiced sound)."}),"\n",(0,n.jsx)(t.h4,{id:"kotlin-3",children:"Kotlin"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"val voicedTime: Float = CalibraBreath.getCumulativeVoicedTime(times, pitchesHz)\n"})}),"\n",(0,n.jsx)(t.h4,{id:"swift-3",children:"Swift"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-swift",children:"let voicedTime: Float = CalibraBreath.getCumulativeVoicedTime(times: times, pitchesHz: pitches)\n"})}),"\n",(0,n.jsx)(t.h4,{id:"parameters-2",children:"Parameters"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Parameter"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"times"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Timestamps in seconds"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"pitchesHz"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Pitch values in Hz (-1 for unvoiced frames)"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Returns:"})," ",(0,n.jsx)(t.code,{children:"Float"})," -- Total voiced time in seconds. Returns ",(0,n.jsx)(t.code,{children:"-1"})," on failure (fewer than 2 samples or mismatched array lengths)."]}),"\n",(0,n.jsx)(t.h3,{id:"computemetrics",children:"computeMetrics"}),"\n",(0,n.jsx)(t.p,{children:"Compute comprehensive breath metrics comparing a student performance to a reference. Internally merges consecutive feedback segments into sung regions, then computes per-region breath capacity and control scores using FFT-based cross-correlation alignment and peak detection."}),"\n",(0,n.jsx)(t.h4,{id:"kotlin-4",children:"Kotlin"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"val metrics: BreathMetrics = CalibraBreath.computeMetrics(\r\n    refTimes = refTimes,\r\n    refPitchesHz = refPitchesHz,\r\n    studentTimes = studentTimes,\r\n    studentPitchesHz = studentPitchesHz,\r\n    feedbackSegmentIndices = feedbackSegmentIndices,\r\n    feedbackStartTimes = feedbackStartTimes,\r\n    feedbackEndTimes = feedbackEndTimes,\r\n    refSegmentStarts = refSegmentStarts,\r\n    refSegmentEnds = refSegmentEnds\r\n)\n"})}),"\n",(0,n.jsx)(t.h4,{id:"swift-4",children:"Swift"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-swift",children:"let metrics: BreathMetrics = CalibraBreath.computeMetrics(\r\n    refTimes: refTimes,\r\n    refPitchesHz: refPitchesHz,\r\n    studentTimes: studentTimes,\r\n    studentPitchesHz: studentPitchesHz,\r\n    feedbackSegmentIndices: feedbackSegmentIndices,\r\n    feedbackStartTimes: feedbackStartTimes,\r\n    feedbackEndTimes: feedbackEndTimes,\r\n    refSegmentStarts: refSegmentStarts,\r\n    refSegmentEnds: refSegmentEnds\r\n)\n"})}),"\n",(0,n.jsx)(t.h4,{id:"parameters-3",children:"Parameters"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Parameter"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"refTimes"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Reference pitch timestamps in seconds"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"refPitchesHz"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Reference pitches in Hz"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"studentTimes"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Student's pitch timestamps in seconds"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"studentPitchesHz"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Student's pitches in Hz"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"feedbackSegmentIndices"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"IntArray"})," / ",(0,n.jsx)(t.code,{children:"[Int]"})]}),(0,n.jsx)(t.td,{children:"Indices of feedback segments"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"feedbackStartTimes"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Start times of feedback segments"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"feedbackEndTimes"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"End times of feedback segments"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"refSegmentStarts"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Reference segment start times"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"refSegmentEnds"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"FloatArray"})," / ",(0,n.jsx)(t.code,{children:"[Float]"})]}),(0,n.jsx)(t.td,{children:"Reference segment end times"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Returns:"})," ",(0,n.jsx)(t.code,{children:"BreathMetrics"})," with capacity, control, and validity."]}),"\n",(0,n.jsx)(t.h2,{id:"result-types",children:"Result Types"}),"\n",(0,n.jsx)(t.h3,{id:"breathmetrics",children:"BreathMetrics"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Property"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"capacity"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"Float"})}),(0,n.jsx)(t.td,{children:"Breath capacity in seconds -- longest sustained phrase"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"control"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"Float"})}),(0,n.jsx)(t.td,{children:"Breath control score (0.0 to 1.0) -- breathing pattern consistency vs. reference"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"isValid"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"Boolean"})}),(0,n.jsx)(t.td,{children:"Whether the result is valid (enough data was available)"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["When data is insufficient or computation fails, ",(0,n.jsx)(t.code,{children:"computeMetrics"})," returns ",(0,n.jsx)(t.code,{children:"BreathMetrics(capacity = -1, control = -1, isValid = false)"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"understanding-breath-capacity",children:"Understanding Breath Capacity"}),"\n",(0,n.jsx)(t.p,{children:"Breath capacity represents the longest sustained phrase duration:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Capacity"}),(0,n.jsx)(t.th,{children:"Level"}),(0,n.jsx)(t.th,{children:"Interpretation"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"< 3 seconds"}),(0,n.jsx)(t.td,{children:"Needs work"}),(0,n.jsx)(t.td,{children:"Short breath support"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"3--5 seconds"}),(0,n.jsx)(t.td,{children:"Beginner"}),(0,n.jsx)(t.td,{children:"Average, typical for untrained singers"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"5--8 seconds"}),(0,n.jsx)(t.td,{children:"Good"}),(0,n.jsx)(t.td,{children:"Solid breath control"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"> 8 seconds"}),(0,n.jsx)(t.td,{children:"Excellent"}),(0,n.jsx)(t.td,{children:"Trained singer level"})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"understanding-breath-control",children:"Understanding Breath Control"}),"\n",(0,n.jsxs)(t.p,{children:["Breath control (from ",(0,n.jsx)(t.code,{children:"computeMetrics"}),") measures how well the student's breathing patterns match the reference performance:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Score"}),(0,n.jsx)(t.th,{children:"Interpretation"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"0.8--1.0"}),(0,n.jsx)(t.td,{children:"Excellent match to reference breathing"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"0.5--0.8"}),(0,n.jsx)(t.td,{children:"Moderate alignment, room for improvement"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"< 0.5"}),(0,n.jsx)(t.td,{children:"Poor match, breathing patterns differ significantly"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"The score is computed by aligning the student's breath function against the reference using FFT cross-correlation, then comparing peak positions and amplitudes with a 0.5-second tolerance and 30% amplitude similarity threshold."}),"\n",(0,n.jsx)(t.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,n.jsx)(t.h3,{id:"post-lesson-breath-report",children:"Post-Lesson Breath Report"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'class BreathReportViewModel(\r\n    private val pitchExtractor: CalibraPitch.ContourExtractor\r\n) : ViewModel() {\r\n\r\n    fun analyzeRecording(audio: FloatArray, sampleRate: Int) {\r\n        viewModelScope.launch {\r\n            val contour = pitchExtractor.extract(audio, sampleRate)\r\n            val times = contour.toTimesArray()\r\n            val pitches = contour.toPitchesArray()\r\n\r\n            if (!CalibraBreath.hasEnoughData(times, pitches)) {\r\n                showMessage("Not enough singing data. Need at least 5 seconds.")\r\n                return@launch\r\n            }\r\n\r\n            val capacity = CalibraBreath.computeCapacity(times, pitches)\r\n            val voicedTime = CalibraBreath.getCumulativeVoicedTime(times, pitches)\r\n\r\n            showResults(\r\n                capacitySeconds = capacity,\r\n                totalSungTime = voicedTime\r\n            )\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,n.jsx)(t.h3,{id:"compare-student-to-reference",children:"Compare Student to Reference"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'fun evaluateBreath(\r\n    refTimes: FloatArray, refPitches: FloatArray,\r\n    studentTimes: FloatArray, studentPitches: FloatArray,\r\n    feedbackIndices: IntArray,\r\n    feedbackStarts: FloatArray, feedbackEnds: FloatArray,\r\n    refStarts: FloatArray, refEnds: FloatArray\r\n) {\r\n    val metrics = CalibraBreath.computeMetrics(\r\n        refTimes = refTimes,\r\n        refPitchesHz = refPitches,\r\n        studentTimes = studentTimes,\r\n        studentPitchesHz = studentPitches,\r\n        feedbackSegmentIndices = feedbackIndices,\r\n        feedbackStartTimes = feedbackStarts,\r\n        feedbackEndTimes = feedbackEnds,\r\n        refSegmentStarts = refStarts,\r\n        refSegmentEnds = refEnds\r\n    )\r\n\r\n    if (metrics.isValid) {\r\n        println("Breath capacity: ${metrics.capacity}s")\r\n        println("Breath control: ${(metrics.control * 100).toInt()}%")\r\n    }\r\n}\n'})}),"\n",(0,n.jsx)(t.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Not enough data"})," -- Need 5+ seconds of actual singing (not silence). Always check with ",(0,n.jsx)(t.code,{children:"hasEnoughData"})," first."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Wrong pitch format"})," -- Use ",(0,n.jsx)(t.code,{children:"-1"})," for unvoiced frames, not ",(0,n.jsx)(t.code,{children:"0"}),". Values at or below 50 Hz are treated as silence internally."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Mismatched array lengths"})," -- ",(0,n.jsx)(t.code,{children:"times"})," and ",(0,n.jsx)(t.code,{children:"pitchesHz"})," must be the same length. Methods return ",(0,n.jsx)(t.code,{children:"-1"})," if they differ."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Timestamps must be evenly spaced"})," -- The sample rate is inferred from the gap between the first two timestamps. Irregular spacing will produce incorrect results."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"./pitch",children:"CalibraPitch"})," -- Extract pitch contours to feed into breath analysis"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"./vad",children:"CalibraVAD"})," -- Detect voice activity before pitch extraction"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"./vocal-range",children:"CalibraVocalRange"})," -- Detect singer's pitch range"]}),"\n"]})]})}function o(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453(e,t,r){r.d(t,{R:()=>c,x:()=>a});var s=r(6540);const n={},i=s.createContext(n);function c(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:c(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);