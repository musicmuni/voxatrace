"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[392],{2864(e,r,n){n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"cookbook/practice-tracker","title":"Practice Tracker","description":"Build a practice app that tracks singing scores over time and shows improvement.","source":"@site/docs/cookbook/practice-tracker.md","sourceDirName":"cookbook","slug":"/cookbook/practice-tracker","permalink":"/voxatrace/cookbook/practice-tracker","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Voice Recorder","permalink":"/voxatrace/cookbook/voice-recorder"},"next":{"title":"Sonix Overview","permalink":"/voxatrace/sonix/overview"}}');var t=n(4848),o=n(8453);const i={sidebar_position:4},a="Practice Tracker",l={},c=[{value:"What You&#39;ll Build",id:"what-youll-build",level:2},{value:"Data Models",id:"data-models",level:2},{value:"Repository",id:"repository",level:2},{value:"ViewModel",id:"viewmodel",level:2},{value:"UI Components",id:"ui-components",level:2},{value:"Progress Dashboard",id:"progress-dashboard",level:3},{value:"History Chart",id:"history-chart",level:3},{value:"Integration with CalibraLiveEval",id:"integration-with-calibraliveeval",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"practice-tracker",children:"Practice Tracker"})}),"\n",(0,t.jsx)(r.p,{children:"Build a practice app that tracks singing scores over time and shows improvement."}),"\n",(0,t.jsx)(r.h2,{id:"what-youll-build",children:"What You'll Build"}),"\n",(0,t.jsx)(r.p,{children:"A progress tracking system:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Record practice sessions with scores"}),"\n",(0,t.jsx)(r.li,{children:"Show score history per song/segment"}),"\n",(0,t.jsx)(r.li,{children:"Visualize improvement over time"}),"\n",(0,t.jsx)(r.li,{children:"Set and track goals"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"data-models",children:"Data Models"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-kotlin",children:'data class PracticeSession(\r\n    val id: String = UUID.randomUUID().toString(),\r\n    val songId: String,\r\n    val timestamp: Long = System.currentTimeMillis(),\r\n    val segmentScores: List<SegmentScore>,\r\n    val overallScore: Float\r\n)\r\n\r\ndata class SegmentScore(\r\n    val segmentIndex: Int,\r\n    val score: Float,\r\n    val attemptNumber: Int\r\n)\r\n\r\ndata class Song(\r\n    val id: String,\r\n    val title: String,\r\n    val artist: String,\r\n    val segments: List<SegmentInfo>\r\n)\r\n\r\ndata class SegmentInfo(\r\n    val index: Int,\r\n    val name: String,  // "Verse 1", "Chorus", etc.\r\n    val difficulty: Difficulty\r\n)\r\n\r\nenum class Difficulty { EASY, MEDIUM, HARD }\r\n\r\ndata class Goal(\r\n    val id: String = UUID.randomUUID().toString(),\r\n    val songId: String,\r\n    val targetScore: Float,\r\n    val deadline: Long?,\r\n    val achieved: Boolean = false\r\n)\n'})}),"\n",(0,t.jsx)(r.h2,{id:"repository",children:"Repository"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-kotlin",children:"class PracticeRepository(private val database: AppDatabase) {\r\n\r\n    // Save practice session\r\n    suspend fun savePracticeSession(session: PracticeSession) {\r\n        database.practiceDao().insert(session.toEntity())\r\n    }\r\n\r\n    // Get sessions for a song\r\n    suspend fun getSessionsForSong(songId: String): List<PracticeSession> {\r\n        return database.practiceDao().getBySongId(songId).map { it.toModel() }\r\n    }\r\n\r\n    // Get score history for a specific segment\r\n    suspend fun getSegmentHistory(songId: String, segmentIndex: Int): List<Float> {\r\n        return getSessionsForSong(songId)\r\n            .flatMap { it.segmentScores }\r\n            .filter { it.segmentIndex == segmentIndex }\r\n            .map { it.score }\r\n    }\r\n\r\n    // Get best score for a song\r\n    suspend fun getBestScore(songId: String): Float? {\r\n        return getSessionsForSong(songId).maxOfOrNull { it.overallScore }\r\n    }\r\n\r\n    // Get average score over last N sessions\r\n    suspend fun getRecentAverage(songId: String, count: Int = 5): Float? {\r\n        return getSessionsForSong(songId)\r\n            .sortedByDescending { it.timestamp }\r\n            .take(count)\r\n            .map { it.overallScore }\r\n            .average()\r\n            .takeIf { !it.isNaN() }\r\n            ?.toFloat()\r\n    }\r\n\r\n    // Get improvement trend (positive = improving)\r\n    suspend fun getImprovementTrend(songId: String): Float {\r\n        val sessions = getSessionsForSong(songId)\r\n            .sortedBy { it.timestamp }\r\n            .takeLast(10)\r\n\r\n        if (sessions.size < 2) return 0f\r\n\r\n        val firstHalf = sessions.take(sessions.size / 2).map { it.overallScore }.average()\r\n        val secondHalf = sessions.takeLast(sessions.size / 2).map { it.overallScore }.average()\r\n\r\n        return (secondHalf - firstHalf).toFloat()\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"viewmodel",children:"ViewModel"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-kotlin",children:"class PracticeTrackerViewModel(\r\n    private val repository: PracticeRepository\r\n) : ViewModel() {\r\n\r\n    private val _state = MutableStateFlow(TrackerState())\r\n    val state: StateFlow<TrackerState> = _state.asStateFlow()\r\n\r\n    data class TrackerState(\r\n        val songs: List<SongProgress> = emptyList(),\r\n        val selectedSong: SongProgress? = null,\r\n        val goals: List<Goal> = emptyList()\r\n    )\r\n\r\n    data class SongProgress(\r\n        val song: Song,\r\n        val bestScore: Float?,\r\n        val recentAverage: Float?,\r\n        val trend: Float,\r\n        val practiceCount: Int,\r\n        val segmentProgress: List<SegmentProgress>\r\n    )\r\n\r\n    data class SegmentProgress(\r\n        val segment: SegmentInfo,\r\n        val bestScore: Float?,\r\n        val recentAverage: Float?,\r\n        val history: List<Float>\r\n    )\r\n\r\n    fun loadSongProgress(songId: String) {\r\n        viewModelScope.launch {\r\n            val song = repository.getSong(songId)\r\n            val sessions = repository.getSessionsForSong(songId)\r\n\r\n            val segmentProgress = song.segments.map { segment ->\r\n                val history = repository.getSegmentHistory(songId, segment.index)\r\n                SegmentProgress(\r\n                    segment = segment,\r\n                    bestScore = history.maxOrNull(),\r\n                    recentAverage = history.takeLast(5).average().toFloat(),\r\n                    history = history\r\n                )\r\n            }\r\n\r\n            val progress = SongProgress(\r\n                song = song,\r\n                bestScore = repository.getBestScore(songId),\r\n                recentAverage = repository.getRecentAverage(songId),\r\n                trend = repository.getImprovementTrend(songId),\r\n                practiceCount = sessions.size,\r\n                segmentProgress = segmentProgress\r\n            )\r\n\r\n            _state.update { it.copy(selectedSong = progress) }\r\n        }\r\n    }\r\n\r\n    fun recordPractice(\r\n        songId: String,\r\n        segmentResults: List<SegmentResult>\r\n    ) {\r\n        viewModelScope.launch {\r\n            val session = PracticeSession(\r\n                songId = songId,\r\n                segmentScores = segmentResults.map {\r\n                    SegmentScore(\r\n                        segmentIndex = it.segment.index,\r\n                        score = it.score,\r\n                        attemptNumber = it.attemptNumber\r\n                    )\r\n                },\r\n                overallScore = segmentResults.map { it.score }.average().toFloat()\r\n            )\r\n\r\n            repository.savePracticeSession(session)\r\n\r\n            // Check goals\r\n            checkGoals(songId, session.overallScore)\r\n\r\n            // Refresh progress\r\n            loadSongProgress(songId)\r\n        }\r\n    }\r\n\r\n    private suspend fun checkGoals(songId: String, score: Float) {\r\n        val goals = repository.getGoalsForSong(songId)\r\n            .filter { !it.achieved && score >= it.targetScore }\r\n\r\n        goals.forEach { goal ->\r\n            repository.markGoalAchieved(goal.id)\r\n            // Notify user\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"ui-components",children:"UI Components"}),"\n",(0,t.jsx)(r.h3,{id:"progress-dashboard",children:"Progress Dashboard"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-kotlin",children:'@Composable\r\nfun ProgressDashboard(progress: SongProgress) {\r\n    Column(modifier = Modifier.padding(16.dp)) {\r\n        // Overall stats\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.SpaceEvenly\r\n        ) {\r\n            StatCard(\r\n                label = "Best",\r\n                value = "${((progress.bestScore ?: 0f) * 100).toInt()}%"\r\n            )\r\n            StatCard(\r\n                label = "Average",\r\n                value = "${((progress.recentAverage ?: 0f) * 100).toInt()}%"\r\n            )\r\n            StatCard(\r\n                label = "Practices",\r\n                value = progress.practiceCount.toString()\r\n            )\r\n        }\r\n\r\n        Spacer(modifier = Modifier.height(16.dp))\r\n\r\n        // Trend indicator\r\n        TrendIndicator(trend = progress.trend)\r\n\r\n        Spacer(modifier = Modifier.height(24.dp))\r\n\r\n        // Segment breakdown\r\n        Text("Segment Progress", style = MaterialTheme.typography.titleMedium)\r\n\r\n        progress.segmentProgress.forEach { segment ->\r\n            SegmentProgressRow(segment)\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nfun TrendIndicator(trend: Float) {\r\n    Row(\r\n        verticalAlignment = Alignment.CenterVertically,\r\n        modifier = Modifier.padding(8.dp)\r\n    ) {\r\n        Icon(\r\n            imageVector = when {\r\n                trend > 0.05f -> Icons.Default.TrendingUp\r\n                trend < -0.05f -> Icons.Default.TrendingDown\r\n                else -> Icons.Default.TrendingFlat\r\n            },\r\n            contentDescription = null,\r\n            tint = when {\r\n                trend > 0.05f -> Color.Green\r\n                trend < -0.05f -> Color.Red\r\n                else -> Color.Gray\r\n            }\r\n        )\r\n        Text(\r\n            text = when {\r\n                trend > 0.05f -> "Improving!"\r\n                trend < -0.05f -> "Keep practicing"\r\n                else -> "Steady"\r\n            },\r\n            modifier = Modifier.padding(start = 8.dp)\r\n        )\r\n    }\r\n}\r\n\r\n@Composable\r\nfun SegmentProgressRow(progress: SegmentProgress) {\r\n    Row(\r\n        modifier = Modifier\r\n            .fillMaxWidth()\r\n            .padding(vertical = 8.dp),\r\n        verticalAlignment = Alignment.CenterVertically\r\n    ) {\r\n        Text(\r\n            text = progress.segment.name,\r\n            modifier = Modifier.weight(1f)\r\n        )\r\n\r\n        // Mini sparkline\r\n        HistorySparkline(\r\n            history = progress.history,\r\n            modifier = Modifier.width(60.dp).height(24.dp)\r\n        )\r\n\r\n        // Best score\r\n        Text(\r\n            text = "${((progress.bestScore ?: 0f) * 100).toInt()}%",\r\n            fontWeight = FontWeight.Bold,\r\n            modifier = Modifier.width(50.dp)\r\n        )\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"history-chart",children:"History Chart"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-kotlin",children:"@Composable\r\nfun HistoryChart(sessions: List<PracticeSession>, modifier: Modifier = Modifier) {\r\n    Canvas(modifier = modifier) {\r\n        if (sessions.isEmpty()) return@Canvas\r\n\r\n        val width = size.width\r\n        val height = size.height\r\n        val padding = 16f\r\n\r\n        val maxScore = 1f\r\n        val minScore = 0f\r\n\r\n        val points = sessions.mapIndexed { index, session ->\r\n            val x = padding + (index.toFloat() / (sessions.size - 1).coerceAtLeast(1)) * (width - 2 * padding)\r\n            val y = height - padding - (session.overallScore / maxScore) * (height - 2 * padding)\r\n            Offset(x, y)\r\n        }\r\n\r\n        // Draw line\r\n        if (points.size > 1) {\r\n            val path = Path().apply {\r\n                moveTo(points.first().x, points.first().y)\r\n                points.drop(1).forEach { lineTo(it.x, it.y) }\r\n            }\r\n            drawPath(path, Color.Blue, style = Stroke(width = 3f))\r\n        }\r\n\r\n        // Draw points\r\n        points.forEach { point ->\r\n            drawCircle(Color.Blue, radius = 6f, center = point)\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"integration-with-calibraliveeval",children:"Integration with CalibraLiveEval"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-kotlin",children:"class PracticeSession(\r\n    private val viewModel: PracticeTrackerViewModel,\r\n    private val song: Song\r\n) {\r\n    private var session: CalibraLiveEval? = null\r\n    private val results = mutableListOf<SegmentResult>()\r\n\r\n    suspend fun start(player: SonixPlayer, recorder: SonixRecorder) {\r\n        val detector = CalibraPitch.createDetector()\r\n\r\n        session = CalibraLiveEval.create(\r\n            reference = song.lessonMaterial,\r\n            detector = detector,\r\n            player = player,\r\n            recorder = recorder\r\n        )\r\n\r\n        session?.prepare()\r\n\r\n        // Collect segment results\r\n        session?.onSegmentComplete { result ->\r\n            results.add(result)\r\n        }\r\n\r\n        // When session completes, save to tracker\r\n        session?.onSessionComplete {\r\n            viewModel.recordPractice(song.id, results)\r\n        }\r\n\r\n        // Start first segment\r\n        session?.playSegment(0)\r\n    }\r\n\r\n    fun close() {\r\n        session?.close()\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"/docs/guides/live-evaluation",children:"Live Evaluation Guide"})," - Scoring details"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"/docs/cookbook/karaoke-app",children:"Karaoke App Recipe"})," - Full karaoke implementation"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"https://github.com/musicmuni/voxatrace-demos",children:"Demo App"})," - Full source"]}),"\n"]})]})}function g(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,r,n){n.d(r,{R:()=>i,x:()=>a});var s=n(6540);const t={},o=s.createContext(t);function i(e){const r=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:r},e.children)}}}]);