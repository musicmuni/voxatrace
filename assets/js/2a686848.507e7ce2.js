"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[992],{2110(e,r,n){n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"cookbook/voice-recorder","title":"Voice Recorder","description":"Build a voice recorder with level monitoring, format options, and playback.","source":"@site/docs/cookbook/voice-recorder.md","sourceDirName":"cookbook","slug":"/cookbook/voice-recorder","permalink":"/cookbook/voice-recorder","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Tuner App","permalink":"/cookbook/tuner-app"},"next":{"title":"Practice Tracker","permalink":"/cookbook/practice-tracker"}}');var i=n(4848),t=n(8453);const l={sidebar_position:3},a="Voice Recorder",d={},c=[{value:"What You&#39;ll Build",id:"what-youll-build",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Data Model",id:"data-model",level:3},{value:"ViewModel",id:"viewmodel",level:3},{value:"UI (Compose)",id:"ui-compose",level:3},{value:"Key Features",id:"key-features",level:2},{value:"Format Selection",id:"format-selection",level:3},{value:"Quality Presets",id:"quality-presets",level:3},{value:"Real-time Level Monitoring",id:"real-time-level-monitoring",level:3},{value:"Next Steps",id:"next-steps",level:2}];function s(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"voice-recorder",children:"Voice Recorder"})}),"\n",(0,i.jsx)(r.p,{children:"Build a voice recorder with level monitoring, format options, and playback."}),"\n",(0,i.jsx)(r.h2,{id:"what-youll-build",children:"What You'll Build"}),"\n",(0,i.jsx)(r.p,{children:"A complete voice recording app:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Record to M4A, MP3, or WAV"}),"\n",(0,i.jsx)(r.li,{children:"Real-time level meter"}),"\n",(0,i.jsx)(r.li,{children:"Playback recorded audio"}),"\n",(0,i.jsx)(r.li,{children:"List and manage recordings"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(r.h3,{id:"data-model",children:"Data Model"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-kotlin",children:"data class Recording(\r\n    val id: String = UUID.randomUUID().toString(),\r\n    val name: String,\r\n    val path: String,\r\n    val durationMs: Long,\r\n    val format: AudioFormat,\r\n    val createdAt: Long = System.currentTimeMillis()\r\n)\n"})}),"\n",(0,i.jsx)(r.h3,{id:"viewmodel",children:"ViewModel"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-kotlin",children:'class VoiceRecorderViewModel : ViewModel() {\r\n    private var recorder: SonixRecorder? = null\r\n    private var player: SonixPlayer? = null\r\n\r\n    private val _state = MutableStateFlow(RecorderState())\r\n    val state: StateFlow<RecorderState> = _state.asStateFlow()\r\n\r\n    data class RecorderState(\r\n        val isRecording: Boolean = false,\r\n        val isPlaying: Boolean = false,\r\n        val recordingDuration: Long = 0,\r\n        val playbackPosition: Long = 0,\r\n        val playbackDuration: Long = 0,\r\n        val level: Float = 0f,\r\n        val recordings: List<Recording> = emptyList(),\r\n        val selectedFormat: AudioFormat = AudioFormat.M4A\r\n    )\r\n\r\n    private val recordingsDir: String\r\n        get() = "${context.filesDir}/recordings"\r\n\r\n    init {\r\n        loadRecordings()\r\n    }\r\n\r\n    fun setFormat(format: AudioFormat) {\r\n        _state.update { it.copy(selectedFormat = format) }\r\n    }\r\n\r\n    fun startRecording(name: String) {\r\n        val extension = when (_state.value.selectedFormat) {\r\n            AudioFormat.M4A -> "m4a"\r\n            AudioFormat.MP3 -> "mp3"\r\n            AudioFormat.WAV -> "wav"\r\n        }\r\n        val path = "$recordingsDir/${name}_${System.currentTimeMillis()}.$extension"\r\n\r\n        recorder = SonixRecorder.create(\r\n            path,\r\n            SonixRecorderConfig.Builder()\r\n                .format(_state.value.selectedFormat)\r\n                .onLevelUpdate { level ->\r\n                    _state.update { it.copy(level = level) }\r\n                }\r\n                .build()\r\n        )\r\n\r\n        recorder?.start()\r\n        _state.update { it.copy(isRecording = true) }\r\n\r\n        // Update duration\r\n        viewModelScope.launch {\r\n            recorder?.duration?.collect { duration ->\r\n                _state.update { it.copy(recordingDuration = duration) }\r\n            }\r\n        }\r\n    }\r\n\r\n    fun stopRecording() {\r\n        recorder?.stop()\r\n        recorder?.release()\r\n\r\n        val recording = Recording(\r\n            name = "Recording ${_state.value.recordings.size + 1}",\r\n            path = recorder?.outputPath ?: "",\r\n            durationMs = _state.value.recordingDuration,\r\n            format = _state.value.selectedFormat\r\n        )\r\n\r\n        recorder = null\r\n        _state.update {\r\n            it.copy(\r\n                isRecording = false,\r\n                recordingDuration = 0,\r\n                level = 0f,\r\n                recordings = it.recordings + recording\r\n            )\r\n        }\r\n\r\n        saveRecordings()\r\n    }\r\n\r\n    suspend fun playRecording(recording: Recording) {\r\n        player?.release()\r\n        player = SonixPlayer.create(recording.path)\r\n\r\n        _state.update {\r\n            it.copy(\r\n                isPlaying = true,\r\n                playbackDuration = player?.duration ?: 0\r\n            )\r\n        }\r\n\r\n        viewModelScope.launch {\r\n            player?.currentTime?.collect { position ->\r\n                _state.update { it.copy(playbackPosition = position) }\r\n            }\r\n        }\r\n\r\n        viewModelScope.launch {\r\n            player?.isPlaying?.collect { playing ->\r\n                if (!playing && _state.value.isPlaying) {\r\n                    _state.update { it.copy(isPlaying = false, playbackPosition = 0) }\r\n                }\r\n            }\r\n        }\r\n\r\n        player?.play()\r\n    }\r\n\r\n    fun stopPlayback() {\r\n        player?.stop()\r\n        player?.release()\r\n        player = null\r\n        _state.update { it.copy(isPlaying = false, playbackPosition = 0) }\r\n    }\r\n\r\n    fun deleteRecording(recording: Recording) {\r\n        File(recording.path).delete()\r\n        _state.update { it.copy(recordings = it.recordings - recording) }\r\n        saveRecordings()\r\n    }\r\n\r\n    private fun loadRecordings() {\r\n        // Load from SharedPreferences or database\r\n    }\r\n\r\n    private fun saveRecordings() {\r\n        // Save to SharedPreferences or database\r\n    }\r\n\r\n    override fun onCleared() {\r\n        recorder?.release()\r\n        player?.release()\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h3,{id:"ui-compose",children:"UI (Compose)"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-kotlin",children:'@Composable\r\nfun VoiceRecorderScreen(viewModel: VoiceRecorderViewModel = viewModel()) {\r\n    val state by viewModel.state.collectAsState()\r\n\r\n    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {\r\n        // Format selector\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.SpaceEvenly\r\n        ) {\r\n            AudioFormat.values().forEach { format ->\r\n                FilterChip(\r\n                    selected = state.selectedFormat == format,\r\n                    onClick = { viewModel.setFormat(format) },\r\n                    label = { Text(format.name) }\r\n                )\r\n            }\r\n        }\r\n\r\n        Spacer(modifier = Modifier.height(24.dp))\r\n\r\n        // Level meter\r\n        LevelMeter(\r\n            level = state.level,\r\n            modifier = Modifier.fillMaxWidth().height(40.dp)\r\n        )\r\n\r\n        // Duration display\r\n        Text(\r\n            text = formatDuration(state.recordingDuration),\r\n            fontSize = 48.sp,\r\n            fontWeight = FontWeight.Bold,\r\n            modifier = Modifier.align(Alignment.CenterHorizontally)\r\n        )\r\n\r\n        Spacer(modifier = Modifier.height(24.dp))\r\n\r\n        // Record button\r\n        RecordButton(\r\n            isRecording = state.isRecording,\r\n            onClick = {\r\n                if (state.isRecording) {\r\n                    viewModel.stopRecording()\r\n                } else {\r\n                    viewModel.startRecording("Recording")\r\n                }\r\n            }\r\n        )\r\n\r\n        Spacer(modifier = Modifier.height(32.dp))\r\n\r\n        // Recordings list\r\n        Text("Recordings", style = MaterialTheme.typography.titleMedium)\r\n\r\n        LazyColumn {\r\n            items(state.recordings) { recording ->\r\n                RecordingItem(\r\n                    recording = recording,\r\n                    isPlaying = state.isPlaying,\r\n                    onPlay = { viewModel.playRecording(it) },\r\n                    onStop = { viewModel.stopPlayback() },\r\n                    onDelete = { viewModel.deleteRecording(it) }\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nfun LevelMeter(level: Float, modifier: Modifier = Modifier) {\r\n    Canvas(modifier = modifier) {\r\n        val width = size.width\r\n        val height = size.height\r\n\r\n        // Background\r\n        drawRoundRect(\r\n            color = Color.Gray.copy(alpha = 0.3f),\r\n            cornerRadius = CornerRadius(8f)\r\n        )\r\n\r\n        // Level bar\r\n        val levelWidth = width * level\r\n        val color = when {\r\n            level < 0.5f -> Color.Green\r\n            level < 0.8f -> Color.Yellow\r\n            else -> Color.Red\r\n        }\r\n        drawRoundRect(\r\n            color = color,\r\n            size = Size(levelWidth, height),\r\n            cornerRadius = CornerRadius(8f)\r\n        )\r\n    }\r\n}\r\n\r\n@Composable\r\nfun RecordButton(isRecording: Boolean, onClick: () -> Unit) {\r\n    Box(\r\n        modifier = Modifier\r\n            .size(80.dp)\r\n            .clip(CircleShape)\r\n            .background(if (isRecording) Color.Red else Color.Red.copy(alpha = 0.7f))\r\n            .clickable(onClick = onClick),\r\n        contentAlignment = Alignment.Center\r\n    ) {\r\n        if (isRecording) {\r\n            Box(\r\n                modifier = Modifier\r\n                    .size(24.dp)\r\n                    .background(Color.White, RoundedCornerShape(4.dp))\r\n            )\r\n        } else {\r\n            Box(\r\n                modifier = Modifier\r\n                    .size(24.dp)\r\n                    .background(Color.White, CircleShape)\r\n            )\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsx)(r.h3,{id:"format-selection",children:"Format Selection"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-kotlin",children:"AudioFormat.M4A  // AAC compressed, small files, good quality\r\nAudioFormat.MP3  // Universal compatibility\r\nAudioFormat.WAV  // Uncompressed, large files, lossless\n"})}),"\n",(0,i.jsx)(r.h3,{id:"quality-presets",children:"Quality Presets"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-kotlin",children:"SonixRecorderConfig.VOICE     // 16kHz mono - smallest files\r\nSonixRecorderConfig.STANDARD  // 44.1kHz stereo - balanced\r\nSonixRecorderConfig.HIGH      // 48kHz stereo - best quality\n"})}),"\n",(0,i.jsx)(r.h3,{id:"real-time-level-monitoring",children:"Real-time Level Monitoring"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-kotlin",children:"recorder?.level?.collect { level ->\r\n    // level is 0.0 to 1.0\r\n    updateVUMeter(level)\r\n}\n"})}),"\n",(0,i.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"../guides/recording-audio",children:"Recording Audio Guide"})," - Detailed recording options"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"../guides/playing-audio",children:"Playing Audio Guide"})," - Playback features"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"https://github.com/musicmuni/voxatrace/tree/main/public/demo-apps",children:"Demo App"})," - Full source"]}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(s,{...e})}):s(e)}},8453(e,r,n){n.d(r,{R:()=>l,x:()=>a});var o=n(6540);const i={},t=o.createContext(i);function l(e){const r=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),o.createElement(t.Provider,{value:r},e.children)}}}]);